								Project<code_stream>

Description:
	codestream is a simple tool to code data from stream.It supports the options -k (key) -e (encode) -d (decode) -h (get help messages).
	The general usage is like to the example :
	    e.g.
		prompt> cat <file> | codestream
	It would reads data from standard input stream and writes data which was coded to standard output stream.
	# EOF will cause stop coding.
	
Design reason:
       I want have a tool to code file to other format that i can custom.

Structure:
	Define a C++ abstract class named Codestream.
	Codestream::_code_procedures	  - A std::vector object which contains code procedures.
				    	  - Codestream' main procedure would use these procedure to operates data by an order was assigned.
	Codestream::_cp_end		  - Index of end point for _code_procedures.

	Codestream::_codestream_error	  - A std::bitset object which has some bits to indicate that error is occurs.

	Codestream::_codestream_flag	  - A std::bitset object which has some bits to saves some flags.

	Codestream::_ip		     	  - Record next position of procedures chain.
	Codestream::_last_ip_start	  - For reset.
	Codestream::_ip_mutex	     	  - Must lock this mutex before access _ip member.
	Codestream::_ip_start		  - _ip cant less than this variable.
	Codestream::_ip_end	     	  - End point of procedures chain.

	Codestream::_last_op_ret     	  - Save last operation return.
	
	Codestream::_state		  - Codestream status.
	Codestream::_state_when_error_occur - For recover from trap.
	Codestream::_state_mutex	  - Saver of _state.

	Codestream::_work_condition	  - std::condtion_variable for woker control.

	Codestream::resetCodestream()	  - Reset codestream.
	Codestream::setStartPoint()	  - Set _ip.
	Codestream::coding()		  - thread wrapper for startCode().
	Codestream::startCode()	     	  - Start coding.
	Codestream::stopCode()	     	  - Stop coding.
	Codestream::restartCode()    	  - Restart coding from breakpoint.
	Codestream::installProcedure()    - Install a procedure into _code_procedures.
					  - /* this function has overload version for install at an assigned position */

	Codestream::uninstallProcedure()  - Uninstall a procedure from _code_procedures.
	Codestream::getProgress()	  - Return _ip,require _ip_mutext.
	Codestream::getLastResult()	  - Return _last_op_ret,require _ip_mutex.
	Codestream::getOpChainSize() 	  - Return _cp_end.
	Codestream::processStateExplain() - Return a C++ string to explain what happen now.
	Codestream::processErrorExplain() - Return a C++ string to explain error.

	Codestream::programErrorRecover() - Error recovery function.
					  - Caller should do the action cause error again.
					  - Caller can use is_<feature> function to check process state.

	Codestream::toggleOpOrder()	  - A toggle to change _ip increase direction.increase
	Codestream::is_processing()	  - Return true -> _state == CODESTREAM_PROGRESSING,otherwise false.
	Codestream::is_suspend()	  - Return true -> _state == CODESTREAM_SUSPEND,otherwise false.
	Codestream::is_shutdown()	  - Return true -> _state == CODESTREAM_SHUTDOWN,otherwise false.
	Codestream::is_execsuccess()	  - Return true -> _cerror == NOERROR,otherwise false.



	enum codestream_state {
	     CODESTREAM_PROGRESSING,		// coding task is working now
	     CODESTREAM_SUSPEND,		// coding task was suspended		
	     CODESTREAM_ERROR,			// an error occurred,controller have to solve error
	     CODESTREAM_SHUTDOWN		// coding task had done
	};

	/* task worker is probably set state to ERROR OR SHUTDOWN */
	/* task worker booter just only set state to PROGRESSING */
	/* if controller stop task,state should be setted to SUSPEND */
	/* if controller recover task from suspend,state should be setted to PROGRESSING */
	/* error handler,if state in ERROR,it must deal with problem that cause error then sets state to PROGRESSING */

	enum codestream_error_state {
	     ERROR_NOINT,
	     ERROR_INSTALLPROCFAILED,
	     ERROR_UNINSTALLPROCFAILED,
	     ERROR_SUSPENDFAILED,
	     ERROR_RECOVERFAILED
	};



	/* ERROR_NOINT : may be none of procedures was installed */
	/* ERROR_INSTALLPROCFAILED : had fault when install procedure */
	/* ERROR_UNINSTALLPROCFAILED : had fault when uninstall procedure */
	/* ERROR_SUSPENDFAILED : it's possible the task in SHUTDOWN */
	/* ERROR_RECOVERFAILED : cant recover from SUSPEND,may be task in SHUTDOWN or in PROGRESSING */

	enum codestream_flag {
	     FLAG_INIT,
	     FLAG_OPDIRECTION
	};
	
	/* FLAG_INIT == 0 -> noinit */
	/* FLAG_INIT == 1 -> had init */
	/* FLAG_OPDIRECTION == 0 -> left to right */
	/* FLAG_OPDIRECTION == 1 -> right to left */

	//!! If want to lock _flag_error_mutex _ip_mutex _state_mutex in a special scope,
	//!! have to lock them in this order :
	//!!   _state_mutex -> _ip_mutex -> _flag_error_mutex
	//!! to release them in opposite order.


	//struct op_arg_ret {
	//       void 	  *b1;		/* b1 should point to a buffer which would contains src data */
	//       size_t	  b1_size;	/* b1_size is the size of data in b1 */
	//       void	  *b2;		/* b2 should point to a buffer which would contains des data */
	//       size_t	  b2_size;	/* b2_size is the size of data in b2 */
	//};
					/* at calling time,b1_size should be the length of data in *b1 */
					/* at calling time,b2_size should be the length of *b2 */

	// the time to call installProcedure() must lock the _ip_mutext, call uninstallProcedure() is alike to that.

	#HEADFILE
	<operation_definition.h>
		All procedure objects would be declared in the file.So the file might has several namespace definitions.
		And also,the procedure wrapper should be declared in the same file.
		Definitions of procedures should be defined in file <operation_definition.cc> #tcc definition would be excepted

	work procedure objects :
	     struct one_two_map;	//  coding algothrim object
	     struct base64_coding;	//  coding algothrim object

	     one_two_map {
	     	map one byte to two bytes.
		port from <cryptor.git> of @Takanashi-Rikka-O
	     }

	     base64_coding {
	     	base64 coding algothrim.
		port from <cryptor.git> of @Takanashi-Rikka-O
	     }

	#HEADFILE
	<ops_wrapper.h>
		This file should contains some wrappers for work-procedures to provide truly working on code_stream.
		main file doesnt need to knows archieve detail to work-procedures,just uses wrappers as well.

		namespace : ops_wrapper

		struct general_coding_struct {
		       char *buff1;
		       size_t length_of_buff1;
		       size_t size_of_buff1;

		       char *buff2;
		       size_t length_of_buff2;
		       size_t size_of_buff2;
		};
		using gcstruct = struct general_coding_struct;

		//  wrapper would decides how to use gcstruct on work-procedures.

		void *ops_wrapper_otm_encode(void *);
		void *ops_wrapper_otm_decode(void *);
		void *ops_wrapper_base64_encode(void *);
		void *ops_wrapper_base64_decode(void *);

		//  because there is not has category tower,have to define
		//  combination version for these functions as well.

		void ops_wrapper_init(void);    //  initialize all ops_wrappers.
		     				//  it init some objects and another things.

Logic order:
	user execute binary file with properly command sequence.
	program create Codestream class.
	set environment.
	start coding.
	shutdown after EOF was received.
	exit.

Feature design:
	-k <num>
		set key for coding.

	-e
		receive data from input stream and coding,output result to output stream.
	
	-d
		receive data from input stream and decoding,output result to output stream.

	-h
		print help messages.

Develop environment:
	gcc 10.3.0
	Linux 3.10
	glibc 2.17
	CentOS 7
	C++ 20

Debug or Other:
      	 state and flag is so chaotic. have to change design between them. (Finished)
	 add new feature that let controller enter sleeping until system state was changed. (Finished)
	 Design wrapper for ops.(Finished) Revise README.(TODO)


Complement:
	<There could place some messages as additional.Addition could explain the project in the further gradation.>

Version:
	v0.01
