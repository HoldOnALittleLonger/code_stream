								Project<code_stream>

Description:
	codestream is a simple tool to code data from stream.It supports the options -k (key) -e (encode) -d (decode) -h (get help messages).
	The general usage is like to the example :
	    e.g.
		prompt> cat <file> | codestream
	It would reads data from standard input stream and writes data which was coded to standard output stream.
	# EOF will cause stop coding.
	
Design reason:
       I want have a tool to code file to other format that i can custom.

Structure:
	Define a C++ abstract class named Codestream.
	Codestream::_code_procedures	  - A std::vector object which contains code procedures.
				    	  - Codestream' main procedure would use these procedure to operates data by an order was assigned.
	Codestream::_cp_end		  - Index of end point for _code_procedures.

	Codestream::_codestream_error	  - A std::bitset object which has some bits to indicate that error is occurs.

	Codestream::_codestream_flag	  - A std::bitset object which has some bits to saves some flags.

	Codestream::_ip		     	  - Record next position of procedures chain.
	Codestream::_last_ip_start	  - For reset.
	Codestream::_ip_mutex	     	  - Must lock this mutex before access _ip member.
	Codestream::_ip_start		  - _ip cant less than this variable.
	Codestream::_ip_end	     	  - End point of procedures chain.

	Codestream::_last_op_ret     	  - Save last operation return.
	
	Codestream::_state		  - Codestream status.
	Codestream::_state_when_error_occur - For recover from trap.
	Codestream::_state_mutex	  - Saver of _state.

	Codestream::_work_condition	  - std::condtion_variable for woker control.

	Codestream::resetCodestream()	  - Reset codestream.
	Codestream::setStartPoint()	  - Set _ip.
	Codestream::coding()		  - thread wrapper for startCode().
	Codestream::startCode()	     	  - Start coding.
	Codestream::stopCode()	     	  - Stop coding.
	Codestream::restartCode()    	  - Restart coding from breakpoint.
	Codestream::installProcedure()    - Install a procedure into _code_procedures.
					  - /* this function has overload version for install at an assigned position */

	Codestream::uninstallProcedure()  - Uninstall a procedure from _code_procedures.
	Codestream::getProgress()	  - Return _ip,require _ip_mutext.
	Codestream::getLastResult()	  - Return _last_op_ret,require _ip_mutex.
	Codestream::getOpChainSize() 	  - Return _cp_end.
	Codestream::processStateExplain() - Return a C++ string to explain what happen now.
	Codestream::processErrorExplain() - Return a C++ string to explain error.

	Codestream::programErrorRecover() - Error recovery function.
					  - Caller should do the action cause error again.
					  - Caller can use is_<feature> function to check process state.

	Codestream::toggleOpOrder()	  - A toggle to change _ip increase direction.increase
	Codestream::is_processing()	  - Return true -> _state == CODESTREAM_PROGRESSING,otherwise false.
	Codestream::is_suspend()	  - Return true -> _state == CODESTREAM_SUSPEND,otherwise false.
	Codestream::is_shutdown()	  - Return true -> _state == CODESTREAM_SHUTDOWN,otherwise false.
	Codestream::is_execsuccess()	  - Return true -> _cerror == NOERROR,otherwise false.



	enum codestream_state {
	     CODESTREAM_PROGRESSING,		// coding task is working now
	     CODESTREAM_SUSPEND,		// coding task was suspended		
	     CODESTREAM_ERROR,			// an error occurred,controller have to solve error
	     CODESTREAM_SHUTDOWN		// coding task had done
	};

	/* task worker is probably set state to ERROR OR SHUTDOWN */
	/* task worker booter just only set state to PROGRESSING */
	/* if controller stop task,state should be setted to SUSPEND */
	/* if controller recover task from suspend,state should be setted to PROGRESSING */
	/* error handler,if state in ERROR,it must deal with problem that cause error then sets state to PROGRESSING */

	enum codestream_error_state {
	     ERROR_NOINT,
	     ERROR_INSTALLPROCFAILED,
	     ERROR_UNINSTALLPROCFAILED,
	     ERROR_SUSPENDFAILED,
	     ERROR_RECOVERFAILED
	};



	/* ERROR_NOINT : may be none of procedures was installed */
	/* ERROR_INSTALLPROCFAILED : had fault when install procedure */
	/* ERROR_UNINSTALLPROCFAILED : had fault when uninstall procedure */
	/* ERROR_SUSPENDFAILED : it's possible the task in SHUTDOWN */
	/* ERROR_RECOVERFAILED : cant recover from SUSPEND,may be task in SHUTDOWN or in PROGRESSING */

	enum codestream_flag {
	     FLAG_INIT,
	     FLAG_OPDIRECTION
	};
	
	/* FLAG_INIT == 0 -> noinit */
	/* FLAG_INIT == 1 -> had init */
	/* FLAG_OPDIRECTION == 0 -> left to right */
	/* FLAG_OPDIRECTION == 1 -> right to left */

	//!! If want to lock _flag_error_mutex _ip_mutex _state_mutex in a special scope,
	//!! have to lock them in this order :
	//!!   _state_mutex -> _ip_mutex -> _flag_error_mutex
	//!! to release them in opposite order.


	//struct op_arg_ret {
	//       void 	  *b1;		/* b1 should point to a buffer which would contains src data */
	//       size_t	  b1_size;	/* b1_size is the size of data in b1 */
	//       void	  *b2;		/* b2 should point to a buffer which would contains des data */
	//       size_t	  b2_size;	/* b2_size is the size of data in b2 */
	//};
					/* at calling time,b1_size should be the length of data in *b1 */
					/* at calling time,b2_size should be the length of *b2 */

	// the time to call installProcedure() must lock the _ip_mutext, call uninstallProcedure() is alike to that.

	#HEADFILE
	<operation_definition.h>
		All procedure objects would be declared in the file.So the file might has several namespace definitions.
		And also,the procedure wrapper should be declared in the same file.
		Definitions of procedures should be defined in file <operation_definition.cc> #tcc definition would be excepted

	work procedure objects :
	     struct one_two_map;	//  coding algothrim object
	     struct base64_coding;	//  coding algothrim object

	     one_two_map {
	     	map one byte to two bytes.
		port from <cryptor.git> of @Takanashi-Rikka-O
	     }

	     base64_coding {
	     	base64 coding algothrim.
		port from <cryptor.git> of @Takanashi-Rikka-O
	     }

	#HEADFILE
	<ops_wrapper.h>
		This file should contains some wrappers for work-procedures to provide truly working on code_stream.
		main file doesnt need to knows archieve detail to work-procedures,just uses wrappers as well.

		namespace : ops_wrapper

		struct general_coding_struct {
		       char *buff1;
		       size_t length_of_buff1;
		       size_t size_of_buff1;

		       char *buff2;
		       size_t length_of_buff2;
		       size_t size_of_buff2;
		};
		using gcstruct = struct general_coding_struct;

		//  wrapper would decides how to use gcstruct on work-procedures.

		//  encode wrapper for otm
		void *ops_wrapper_otm_encode(void *gcs);

		//  decode wrapper for otm
		void *ops_wrapper_otm_decode(void *gcs);

		//  encode wrapper for base64
		void *ops_wrapper_base64_encode(void *gcs);

		//  decode wrapper for base64
		void *ops_wrapper_base64_decode(void *gcs);

		//  work together.
		//  this function is used to combine code functions each using
		//  gcstruct.
		//  it should in the working chain :
		//    code1 -> ops_wrapper_gcwt -> code2
		//    decode1 -> ops_wrapper_gcwt -> decode2
		//    #  between coding-object1 and coing-object2
		void *ops_wrapper_gcwt(void *gcs);

		//  gerneral key-values for unsigned long.		
		union gc_keys_ul {
		      unsigned long otm_key;
		      //  unsigned long base64_key;
		      //  ... more
		};

		void ops_wrapper_init(void) noexcept(false);    //  initialize all ops_wrappers.
		     			    			//  it init some objects and another things.
								//  if there occurs any exception,init() will throw it but doesnt catch it as well.

		void ops_wrapper_otm_key(unsigned short);	//  set key-value for otm.
		     				  		//  init-function will use the key-value to
								//  init target object.

	#CODEFILE
	<ops_wrapper.cc>
		it contains the definitions of functions and other things.
	
		namespace : ops

		//  the objects			  
		static otm::otm_object *otm_bewrapped = nullptr;
		static base64::base64_object *base64_bewrapped = nullptr;
		
		//  init function for otm.
		//  it would be invoked in ops_wrapper_init() with
		//  gc_keys_ul.otm_key.
		static void otm_init(unsigned short x);


		namespace : owa 
		//  all ops_wrapped aid function should in this namespace.

		//  the main work-together combine function
		void ow_gcs_all_wt(gcstruct *gcs);

		namespace : ops_wrapper

		//  let ops_wrapper_init() just be invoked at onece.
		static unsigned short ops_wrapper_init_record = 0;

		static unsigned short cwer = 0;  //  record key.
		#define CWER_OTM 0
		#define CWER_BASE64 1
		
		
		//  constructure all objects that be wrapped by ops_wrapper.
		static void construct_ops_wrappers(void);

		//  check if the objects realy be existed,that means
		//  succeed to create them.
		static void if_wrappers_exist(void) noexcept(false);

		... other definitions.

	#MAINFILE
	codestream :
		The designing of codestream.
		Support several options for program features.
		"-k:-e:-d:-h"
		Every option should as a standalong function wait invoking by main.

		//  codestream_main - Codestream object.
		Codestream codestream_main;

		//  data_src - a istream pointer.
		//    #  codestream should point to
		//    #	   cin | ifstream object
		istream *data_src;

		//  gcs - general coding structure object.
		gcstruct gcs;

		//  src_from - where data from.
		//    #  FFILE  - from file (file path)
		//    #  FSTDIN - from stdin (-,- means stdin)
		//    #  FCMD   - from command line ("123...abc..")
		unsigned short src_from;

		All of option functions should return an int value.
		0 - true
		-1 - false
				
		//  main_optionf_k - option function for option<k key>.
		//    @thekey : key value.
		//    return - 0 or -1
		main_optionf_k(thekey);   

		//  main_optionf_e - option function for option<e encode>.
		//    @arg : @arg for encode.
		//    return - 0 or -1
		//    #  @arg maybe a path of file,or a string,or data stream from stdin.
		main_optionf_e(arg);

		//  main_option_d - option function for option<d decode>.
		//    @arg : @arg for decode.
		//    return - 0 or -1
		//    #  @arg maybe a path of file,or a string,or data stream from stdin.
		main_optionf_d(arg);

		//  main_optionf_h - option function for option<h help>.
		//   return : void
		//   #  main_optionf_h() doesnt return anything.
		main_optionf_h(void);
		
		//  main_optionf_f - option function for option<f file>.
		//    #  this function should just set flag to indicates that
		//    #  program should interprets the value followed -e to a
		//    #  file path.
		main_optionf_f(arg);

		because program maybe receives data from stdin,or reads file,or from user give.
		for deal with general situation,should make a stream and operates it.
		
		s1>  file path
		     file stream
		 
		s2>  stdin
		     file stream,but it associated to stdin

		s3>  string
		     string got from user,should create a stream and fill it with the string.
		
		//  main_create_stream() - create a stream and return it.
		//    #  cin is istream object.
		//    #  ifstream : public basic_istream
		//    #  this means could use a istream pointer to point cin or ifstream object.
		main_create_stream(situations);

		//  quesition : how to create a stream and fill it with the string?(TODO)
		//    write string into stdin,then let the pointer point to cin?
		//    use cin.putback().

		//  main_coding - read data and output after operations done.
		main_coding(arg);

		
		ERROR CODE :
		      EINVLIDKEY     -  invalid key was given.
		      EOPTION	     -  unknown option or that option need an argument.
		      EENCODE	     -  occur error while encode.
		      EDECODE	     -  occur error while decode.
		      EFPERMISSION   -  have no permission to access file.
		      
		

Logic order:
	user execute binary file with properly command sequence.
	program create Codestream class.
	set environment.
	start coding.
	shutdown after EOF was received.
	exit.

Feature design:
	-k <num>
		set key for coding.

	-e
		receive data from input stream and coding,output result to output stream.
	
	-d
		receive data from input stream and decoding,output result to output stream.
	
	-f
		input from file,this option should has a file-name after it.

	-h
		print help messages.

Develop environment:
	gcc 10.3.0
	Linux 3.10
	glibc 2.17
	CentOS 7
	C++ 20

Debug or Other:
      	 state and flag is so chaotic. have to change design between them. (Finished)
	 add new feature that let controller enter sleeping until system state was changed. (Finished)
	 Design wrapper for ops.(Finished) Revise README.(Finished)


Complement:
	<There could place some messages as additional.Addition could explain the project in the further gradation.>

Version:
	v0.01
